package com.lightbend.futures;

import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;



class CachedCustomerRepository implements CustomerRepository {

    private final ObjectStore objectStore;
    private final ConcurrentHashMap<UUID, Customer> cache = new ConcurrentHashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    CachedCustomerRepository(ObjectStore objectStore) {
        this.objectStore = objectStore;
    }

    @Override
    public void saveCustomer(Customer customer) {
        lock.writeLock().lock();

        objectStore.write(customer.getId(), customer);
        cache.put(customer.getId(), customer);

        lock.writeLock().unlock();
    }

    @Override
    public Optional<Customer> getCustomer(UUID customerId) {
        lock.readLock().lock();

        Optional<Customer> result;

        if(cache.containsKey(customerId)) {
            result = Optional.of(cache.get(customerId));
        } else {
            result = objectStore.read(customerId).map(obj -> (Customer) obj);
        }

        lock.readLock().unlock();

        return result;
    }
}
package com.lightbend.futures;

import java.io.Serializable;
import java.util.Objects;
import java.util.UUID;

/**
 * Customer is an immutable data class that contains the details about a
 * customer.
 */
public class Customer implements Serializable {

    private final UUID id;
    private final String firstName;
    private final String lastName;
    private final String address;
    private final String phoneNumber;

    UUID getId() {
        return id;
    }

    String getFirstName() {
        return firstName;
    }

    String getLastName() {
        return lastName;
    }

    String getAddress() {
        return address;
    }

    String getPhoneNumber() {
        return phoneNumber;
    }

    Customer(UUID id,
                    String firstName,
                    String lastName,
                    String address,
                    String phoneNumber) {
        this.id = id;
        this.firstName = firstName;
        this.lastName = lastName;
        this.address = address;
        this.phoneNumber = phoneNumber;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Customer customer = (Customer) o;
        return Objects.equals(id, customer.id) &&
                Objects.equals(firstName, customer.firstName) &&
                Objects.equals(lastName, customer.lastName) &&
                Objects.equals(address, customer.address) &&
                Objects.equals(phoneNumber, customer.phoneNumber);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, firstName, lastName, address, phoneNumber);
    }
}
package com.lightbend.futures;

import java.util.Optional;
import java.util.UUID;

public interface CustomerRepository {
    void saveCustomer(Customer customer);
    Optional<Customer> getCustomer(UUID customerId);
}package com.lightbend.futures;

import java.util.Optional;
import java.util.UUID;

class CustomerService {

    private CustomerRepository customerRepository;

    CustomerService(CustomerRepository customerRepository) {
        this.customerRepository = customerRepository;
    }

    UUID addCustomer(String firstName, String lastName, String address, String phoneNumber) {
        UUID customerId = UUID.randomUUID();
        customerRepository.saveCustomer(new Customer(
            customerId,
            firstName,
            lastName,
            address,
            phoneNumber
        ));

        return customerId;
    }

    Optional<String> getCustomerFirstName(UUID customerId) {
        return customerRepository.getCustomer(customerId).map(Customer::getFirstName);
    }

    Optional<String> getCustomerLastName(UUID customerId) {
        return customerRepository.getCustomer(customerId).map(Customer::getLastName);
    }

    Optional<String> getCustomerAddress(UUID customerId) {
        return customerRepository.getCustomer(customerId).map(Customer::getAddress);
    }

    Optional<String> getCustomerPhoneNumber(UUID customerId) {
        return customerRepository.getCustomer(customerId).map(Customer::getPhoneNumber);
    }
}
package com.lightbend.futures;

import java.io.*;
import java.nio.file.Path;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;



/**
 * The ObjectStore is a file based storage mechanism for Objects. It is
 * intended to provide blocking operations that simulate operations that would
 * traditionally use a database, an external HTTP endpoint, etc.
 */
class FileBasedObjectStore implements ObjectStore {

    private final File storeFolder;

    // This would be more efficient if written with a lock per file.
    // However for simplicity we are going with a single lock instead.
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    /**
     * Construct an ObjectStore Store
     * @param storeFolder This folder will be used to store the object data.
     */
    FileBasedObjectStore(Path storeFolder) {
        this.storeFolder = storeFolder.toFile();
        assert(this.storeFolder.exists());
        assert(this.storeFolder.isDirectory());
    }

    /**
     * Reads an object from the file store.
     * @param id - The ID of the object
     * @return The object if it exists or empty if it does not.
     */
    @Override
    public Optional<Object> read(UUID id) {
        lock.readLock().lock();

        File file = new File(storeFolder, id.toString());

        Optional<Object> result;

        try (
            FileInputStream fileIn = new FileInputStream(file);
            ObjectInputStream in = new ObjectInputStream(fileIn)
        ) {
            result = Optional.ofNullable(in.readObject());
        } catch ( IOException | ClassNotFoundException ex) {
            result = Optional.empty();
        } finally {
            lock.readLock().unlock();
        }

        return result;
    }

    /**
     * Writes an object to a file in the file store.
     * @param id - The id of the object being written.
     * @param obj - The object to be written.
     * @return true if the write was successful, false if it failed.
     */
    @Override
    public boolean write(UUID id, Object obj) {
        lock.writeLock().lock();

        File file = new File(storeFolder, id.toString());

        boolean result;

        try (
            FileOutputStream fileOut = new FileOutputStream(file);
            ObjectOutputStream out = new ObjectOutputStream(fileOut)
        ) {
            out.writeObject(obj);
            result = true;
        } catch (IOException ex) {
            result = false;
        } finally {
            lock.writeLock().unlock();
        }

        return result;
    }
}
package com.lightbend.futures;

import java.util.Optional;
import java.util.UUID;

public interface ObjectStore {
    Optional<Object> read(UUID id);
    boolean write(UUID id, Object obj);
}